<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>G·ª≠i c√°c t√¨nh y√™u üíó</title>

<!-- Import font Poppins -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">

<style>
  :root {
    --bg1: #fff8fb;
    --bg2: #ffeef6;
    --accent: #ff4f81;
  }

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: "Poppins", system-ui, Arial, sans-serif;
    background: linear-gradient(180deg, var(--bg1), var(--bg2));
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    touch-action: none;
  }

  .screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity .8s ease, transform .8s ease;
  }
  .hidden { 
    opacity: 0; 
    pointer-events: none; 
    transform: scale(.98); 
  }

  .centerText {
    position: absolute;
    z-index: 50;
    text-align: center;
    padding: 16px 28px;
    border-radius: 999px;
    border: 2px solid rgba(255,100,150,0.14);
    background: rgba(255,255,255,0.92);
    box-shadow: 0 14px 40px rgba(255,120,160,0.1);
    cursor: pointer;
    transition: transform .15s ease;
    max-width: 90%;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }
  .centerText:active { transform: scale(0.98); }
  .centerText .title {
    font-size: clamp(20px, 5vw, 32px);
    color: var(--accent);
    font-weight: 800;
    line-height: 1.2;
  }

  .finalText {
    position: absolute;
    text-align: center;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: opacity 1.5s ease;
    z-index: 70;
    width: 80%;
    max-width: 300px;
    pointer-events: none;
  }
  .finalText.show { opacity: 1; }
  .finalText .main {
    font-size: clamp(18px, 5vw, 28px);
    font-weight: 800;
    color: #fff;
    text-shadow: 0 2px 10px rgba(255,100,160,0.9);
    line-height: 1.3;
    margin-bottom: 6px;
  }
  .finalText .sub {
    color: #fff;
    font-size: clamp(12px, 3vw, 16px);
    text-shadow: 0 2px 6px rgba(255,120,180,0.8);
    line-height: 1.4;
  }
</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>
<canvas id="mainCanvas"></canvas>

<!-- M√†n 1 -->
<div id="screen1" class="screen">
  <div class="centerText" id="cta">
    <div class="title">For my love üíó</div>
  </div>
</div>

<!-- M√†n 2 -->
<div id="screen2" class="screen hidden">
  <div id="finalText" class="finalText">
    <div class="main">Happy Women's Day</div>
    <div class="sub">Thanks for always being your beautiful, strong self.</div>
  </div>
</div>

<script>
const bgCanvas = document.getElementById("bgCanvas");
const mainCanvas = document.getElementById("mainCanvas");
const bgCtx = bgCanvas.getContext("2d");
const mCtx = mainCanvas.getContext("2d");

function fit() {
  const DPR = window.devicePixelRatio || 1;
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  bgCanvas.width = width * DPR;
  bgCanvas.height = height * DPR;
  mainCanvas.width = width * DPR;
  mainCanvas.height = height * DPR;
  
  bgCtx.scale(DPR, DPR);
  mCtx.scale(DPR, DPR);
}

fit();
window.addEventListener("resize", fit);
window.addEventListener("orientationchange", function() {
  setTimeout(fit, 100);
});

// --- n·ªÅn hoa & tim r∆°i --- FIXED ---
const bgParticles = [];
const BG_COUNT = Math.round((window.innerWidth * window.innerHeight) / 90000 * 25); // Gi·∫£m s·ªë l∆∞·ª£ng

function spawnParticle() {
  const type = Math.random() < 0.6 ? "petal" : "heart";
  return {
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    vx: (Math.random() - 0.5) * 0.3, // Gi·∫£m t·ªëc ƒë·ªô
    vy: 0.3 + Math.random() * 0.5,
    size: 4 + Math.random() * 10, // Nh·ªè h∆°n
    rot: Math.random() * Math.PI * 2,
    drot: (Math.random() - 0.5) * 0.01,
    alpha: 0.4 + Math.random() * 0.3, // Trong su·ªët h∆°n
    type
  };
}

for (let i = 0; i < BG_COUNT; i++) bgParticles.push(spawnParticle());

function drawBg(dt) {
  bgCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
  for (let p of bgParticles) {
    p.x += p.vx;
    p.y += p.vy;
    p.rot += p.drot;
    bgCtx.save();
    bgCtx.globalAlpha = p.alpha;
    bgCtx.translate(p.x, p.y);
    bgCtx.rotate(p.rot);
    if (p.type === "petal") {
      bgCtx.fillStyle = "rgba(255,200,220,0.6)";
      bgCtx.beginPath();
      bgCtx.ellipse(0, 0, p.size * 0.4, p.size * 0.8, 0, 0, Math.PI * 2);
      bgCtx.fill();
    } else {
      bgCtx.scale(p.size / 15, p.size / 15);
      bgCtx.beginPath();
      bgCtx.moveTo(0, 0);
      bgCtx.bezierCurveTo(0, -4, -3, -9, -8, -9);
      bgCtx.bezierCurveTo(-16, -9, -16, 4, 0, 13);
      bgCtx.bezierCurveTo(16, 4, 16, -9, 8, -9);
      bgCtx.bezierCurveTo(3, -9, 0, -4, 0, 0);
      bgCtx.fillStyle = "rgba(255,120,160,0.5)";
      bgCtx.fill();
    }
    bgCtx.restore();
    if (p.y > window.innerHeight + 30 || p.x < -30 || p.x > window.innerWidth + 30) {
      p.x = Math.random() * window.innerWidth;
      p.y = -20;
    }
  }
}

// --- tim gh√©p - IMPROVED ---
let assembling = false, assembled = false, assembleParticles = [];
let heartBeatPhase = 0;

// T·∫°o h√¨nh tim m·∫£nh mai h∆°n
function heartPoints(cx, cy, s, count = 300) {
  const pts = [];
  for (let i = 0; i < count; i++) {
    const t = Math.PI * 2 * (i / count);
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
    pts.push({x: cx + x * s * 0.8, y: cy + y * s * 0.8}); // Nh·ªè h∆°n, m·∫£nh h∆°n
  }
  return pts;
}

function startAssemble() {
  assembleParticles = [];
  const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
  const s = Math.min(window.innerWidth, window.innerHeight) / 50; // Nh·ªè h∆°n
  const pts = heartPoints(cx, cy, s);
  
  for (let pt of pts) {
    const angle = Math.random() * Math.PI * 2;
    const distance = 100 + Math.random() * 200;
    const startX = cx + Math.cos(angle) * distance;
    const startY = cy + Math.sin(angle) * distance;
    
    assembleParticles.push({
      x: startX,
      y: startY,
      tx: pt.x, 
      ty: pt.y,
      vx: 0, 
      vy: 0,
      size: 2 + Math.random() * 3, // Nh·ªè h∆°n
      hue: 330 + Math.random() * 20,
      alpha: 0.8 + Math.random() * 0.2,
      delay: Math.random() * 1000
    });
  }
  assembling = true;
  heartBeatPhase = 0;
}

function drawAssemble(dt) {
  if (!assembling) return;
  
  let done = true;
  const currentTime = Date.now();
  
  for (let p of assembleParticles) {
    if (currentTime < p.delay) continue;
    
    const dx = p.tx - p.x;
    const dy = p.ty - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > 2) {
      done = false;
      p.vx += dx * 0.08;
      p.vy += dy * 0.08;
      p.vx *= 0.85;
      p.vy *= 0.85;
      p.x += p.vx;
      p.y += p.vy;
    }
    
    mCtx.save();
    mCtx.globalAlpha = p.alpha;
    mCtx.fillStyle = `hsla(${p.hue}, 85%, 65%, 0.9)`;
    mCtx.beginPath();
    mCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    mCtx.fill();
    mCtx.restore();
  }
  
  if (done && !assembled) {
    assembled = true;
    startHeartBeat();
  }
}

// Hi·ªáu ·ª©ng tim ƒë·∫≠p
function startHeartBeat() {
  heartBeatPhase = 0;
  animateHeartBeat();
}

function animateHeartBeat() {
  if (!assembled) return;
  
  heartBeatPhase += 0.05;
  const scale = 1 + Math.sin(heartBeatPhase) * 0.05;
  
  mCtx.save();
  mCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
  
  // V·∫Ω l·∫°i c√°c h·∫°t v·ªõi hi·ªáu ·ª©ng ƒë·∫≠p
  const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
  
  for (let p of assembleParticles) {
    const dx = p.x - cx;
    const dy = p.y - cy;
    const newX = cx + dx * scale;
    const newY = cy + dy * scale;
    
    mCtx.save();
    mCtx.globalAlpha = p.alpha;
    mCtx.fillStyle = `hsla(${p.hue}, 85%, 65%, 0.9)`;
    mCtx.beginPath();
    mCtx.arc(newX, newY, p.size, 0, Math.PI * 2);
    mCtx.fill();
    mCtx.restore();
  }
  
  mCtx.restore();
  
  if (assembled) {
    requestAnimationFrame(animateHeartBeat);
  }
}

// Animation loop ch√≠nh
let last = performance.now();
function loop(now) {
  const dt = now - last; 
  last = now;
  
  drawBg(dt);
  if (!assembled) {
    drawAssemble(dt);
  }
  
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

const screen1 = document.getElementById("screen1");
const screen2 = document.getElementById("screen2");
const cta = document.getElementById("cta");
const finalText = document.getElementById("finalText");

function handleClick() {
  screen1.classList.add("hidden");
  setTimeout(() => {
    screen1.style.display = "none";
    screen2.style.display = "flex";
    screen2.classList.remove("hidden");
    setTimeout(startAssemble, 300);
    
    const timer = setInterval(() => {
      if (assembled) { 
        setTimeout(() => {
          finalText.classList.add("show");
        }, 500);
        clearInterval(timer); 
      }
    }, 100);
  }, 500);
}

// Event listeners
cta.addEventListener("click", handleClick);
cta.addEventListener("touchend", function(e) {
  e.preventDefault();
  handleClick();
});

// Preload ƒë·ªÉ tr√°nh gi·∫≠t
window.addEventListener('load', function() {
  setTimeout(() => {
    document.body.style.opacity = '1';
  }, 100);
});
</script>

</body>
</html>